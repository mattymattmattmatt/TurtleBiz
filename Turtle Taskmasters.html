<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Turtle Taskmasters</title>
    <style>
        /* Reset default margins and paddings */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1e1e1e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* Container for the game and HUD */
        .game-container {
            position: relative;
            margin-top: 20px;
        }

        /* Canvas Styling */
        #gameCanvas {
            background-color: #2c2c2c;
            border: 3px solid #00b894;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 184, 148, 0.7);
        }

        /* HUD Styling */
        #hud {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 0 20px;
            font-size: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }

        #hud .player-tally {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #hud .level-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Audio Controls Styling */
        #audioControls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #audioControls button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #34495e;
            border: none;
            color: #ecf0f1;
            border-radius: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        #audioControls button:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
        }

        #audioControls button:active {
            background-color: #1a252f;
            transform: translateY(0);
        }

        /* Start, Countdown, and Game Over Screens */
        #startScreen, #gameOverScreen, #countdownOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 2px solid #00b894;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 184, 148, 0.9);
            z-index: 100; /* Ensures overlaying */
            display: none; /* Hidden by default */
        }

        #startScreen.active, #countdownOverlay.active {
            display: block;
        }

        #gameOverScreen.active {
            display: block;
        }

        #startScreen h1, #gameOverScreen h1, #countdownOverlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #00b894;
            text-shadow: 2px 2px #000;
        }

        #startScreen p, #gameOverScreen p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #countdownOverlay h1 {
            font-size: 100px;
            color: #FFD700;
            text-shadow: 3px 3px #000;
        }

        button {
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            background-color: #00b894;
            border: none;
            color: #fff;
            border-radius: 25px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 15px rgba(0, 184, 148, 0.4);
        }

        button:hover {
            background-color: #019875;
            transform: translateY(-2px);
        }

        button:active {
            background-color: #017d61;
            transform: translateY(0);
        }

        /* Rules Section Styling */
        #rules {
            max-width: 800px;
            width: 90%;
            margin: 30px auto;
            padding: 20px 30px;
            background-color: #2c2c2c;
            border: 2px solid #00b894;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 184, 148, 0.5);
        }

        #rules h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #00b894;
            text-shadow: 1px 1px #000;
        }

        #rules ul {
            list-style-type: disc;
            padding-left: 20px;
            line-height: 1.6;
        }

        #rules ul ul {
            list-style-type: circle;
            padding-left: 20px;
        }

        /* Responsive Design */
        @media (max-width: 850px) {
            #hud {
                flex-direction: column;
                gap: 10px;
                font-size: 18px;
            }

            button {
                padding: 10px 25px;
                font-size: 16px;
            }

            #rules {
                padding: 15px 20px;
            }

            #rules h2 {
                font-size: 24px;
            }

            #rules ul {
                font-size: 16px;
            }

            #countdownOverlay h1 {
                font-size: 60px;
            }
        }

        /* Animation Classes */
        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
    </style>
</head>
<body>
    <!-- Game and HUD Container -->
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="hud">
            <div class="player-tally" id="player1Tally">
                <strong id="player1Name" style="color:#00b894;"></strong> <span id="player1Count">0</span>
            </div>
            <div class="level-display">
                <strong>Level:</strong> <span id="level">1</span>
            </div>
            <div class="player-tally" id="player2Tally">
                <strong id="player2Name" style="color:#FF4081;"></strong> <span id="player2Count">0</span>
            </div>
            <!-- Audio Controls -->
            <div id="audioControls">
                <button id="toggleMusic">Music: On</button>
                <button id="toggleSFX">SFX: On</button>
            </div>
        </div>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="active">
        <h1>Turtle Taskmasters</h1>
        <p>Navigate your turtles through the ocean, collect coins, and avoid Tiger Sharks to be the top Taskmaster!</p>
        <button id="startButton" disabled>Start Game</button> <!-- Initially disabled until images load -->
    </div>

    <!-- Countdown Overlay -->
    <div id="countdownOverlay">
        <h1 id="countdownNumber">3</h1>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1>Game Over</h1>
        <p><strong id="gameOverPlayer1"></strong> Coins Collected: <span id="finalPlayer1">0</span></p>
        <p><strong id="gameOverPlayer2"></strong> Coins Collected: <span id="finalPlayer2">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <!-- Game Rules Section -->
    <div id="rules">
        <h2>How to Play "Turtle Taskmasters"</h2>
        <p>Welcome to "Turtle Taskmasters"! In this retro-inspired arcade game, you and your partner take on the roles of diligent office turtles navigating through a hazardous ocean environment. Your goal is to collect as many treasure as possible in each level while avoiding obstacles. As you progress, the number of tasks and obstacles increases, enhancing the challenge. Here's how to get started:</p>
        <ul>
            <li><strong>Controls:</strong>
                <ul>
                    <li><strong>Player 1:</strong> <code>W</code> (Up), <code>A</code> (Left), <code>S</code> (Down), <code>D</code> (Right) to apply thrust and move.</li>
                    <li><strong>Player 2:</strong> <code>I</code> (Up), <code>J</code> (Left), <code>K</code> (Down), <code>L</code> (Right) to apply thrust and move.</li>
                </ul>
            </li>
            <li><strong>Objectives:</strong>
                <ul>
                    <li>Collect <span style="color:#FFD700;">Coins</span> to score points.</li>
                    <li>Avoid <span style="color:#FF5722;">Tiger Sharks</span> that can eliminate a turtle upon collision.</li>
                </ul>
            </li>
            <li><strong>Game Flow:</strong>
                <ul>
                    <li>Each level starts with a fixed number of coins and Tiger Sharks. Collect all the coins to advance to the next level.</li>
                    <li>With each level cleared, the number of tasks and obstacles doubles, increasing the difficulty.</li>
                    <li>If a turtle gets eaten by a Tiger Shark, it becomes hidden and will respawn after 2 seconds.</li>
                    <li>The game ends after completing level 5.</li>
                    <li>Restart the game by clicking the "Play Again" button on the Game Over screen.</li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Audio Elements -->
    <!-- Updated src paths to point to the 'audio' folder -->
    <audio id="bgMusic" loop>
        <source src="audio/background-music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="collectCoinSound">
        <source src="audio/collect-task.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="collisionSound">
        <source src="audio/collision.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="levelUpSound">
        <source src="audio/level-up.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <script>
        // Get Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // HUD Elements
        const levelSpan = document.getElementById('level');
        const player1CountElement = document.getElementById('player1Count');
        const player2CountElement = document.getElementById('player2Count');
        const player1NameElement = document.getElementById('player1Name');
        const player2NameElement = document.getElementById('player2Name');
        const gameOverPlayer1 = document.getElementById('gameOverPlayer1');
        const gameOverPlayer2 = document.getElementById('gameOverPlayer2');

        // Start, Countdown, and Game Over Screens
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const countdownNumber = document.getElementById('countdownNumber');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalPlayer1 = document.getElementById('finalPlayer1');
        const finalPlayer2 = document.getElementById('finalPlayer2');
        const restartButton = document.getElementById('restartButton');

        // Audio Elements
        const bgMusic = document.getElementById('bgMusic');
        const collectCoinSound = document.getElementById('collectCoinSound');
        const collisionSound = document.getElementById('collisionSound');
        const levelUpSound = document.getElementById('levelUpSound');

        // Audio Control Buttons
        const toggleMusicButton = document.getElementById('toggleMusic');
        const toggleSFXButton = document.getElementById('toggleSFX');

        // Game Variables
        let gameInterval;
        let currentLevel = 1;
        const maxLevel = 5;
        let coinsPerLevel = 2;
        let sharksPerLevel = 2;
        let keysPressed = {};

        // Collision Buffer
        const COLLISION_BUFFER = 5;

        // Tally Variables
        let player1Coins = 0;
        let player2Coins = 0;

        // Particle Management
        let particles = [];
        let thrustBubbles = []; // Array for thrust bubbles

        // Respawn Flags
        let respawnTimeouts = {
            player1: null,
            player2: null
        };

        // Audio Control States
        let musicMuted = false;
        let sfxMuted = false;

        // List of 100 Unique Names
        const nameList = [
            "Aiden", "Bella", "Caleb", "Daisy", "Ethan", "Fiona", "Gavin", "Hannah",
            "Isaac", "Jasmine", "Kai", "Lily", "Mason", "Nora", "Oliver", "Penelope",
            "Quentin", "Ruby", "Sebastian", "Tessa", "Ulysses", "Violet", "Wyatt",
            "Xander", "Yara", "Zane", "Amelia", "Benjamin", "Chloe", "Daniel",
            "Ella", "Felix", "Grace", "Henry", "Isla", "Jack", "Katherine", "Leo",
            "Mia", "Noah", "Olivia", "Parker", "Quinn", "Riley", "Samuel", "Sophia",
            "Thomas", "Uma", "Victoria", "William", "Ximena", "Yosef", "Zara",
            "Aaron", "Bianca", "Charles", "Delilah", "Elijah", "Freya", "George",
            "Hazel", "Ian", "Juliana", "Kevin", "Layla", "Matthew", "Natalie",
            "Owen", "Paisley", "Quincy", "Rowan", "Sienna", "Tristan", "Ursula",
            "Vincent", "Willow", "Xenia", "Yvonne", "Zachary", "Ada", "Brandon",
            "Clara", "Dominic", "Emilia", "Finn", "Georgia", "Hudson", "Ivy",
            "Jasper", "Kylie", "Lucas", "Madeline"
        ];

        // Shuffle Function to Randomize Names
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Assign Random Names to Players
        function assignPlayerNames() {
            const shuffledNames = shuffle([...nameList]);
            const player1Name = shuffledNames.pop();
            const player2Name = shuffledNames.pop();
            return { player1Name, player2Name };
        }

        // Load Images
        const backgroundImage = new Image();
        backgroundImage.src = 'images/turtle-gamebg.png';

        const sharkImage = new Image();
        sharkImage.src = 'images/shark.png';

        const coinImage = new Image();
        coinImage.src = 'images/gamecoin.png';

        // Load Turtle Images
        const player1Image = new Image();
        player1Image.src = 'images/p1-turtle.png';

        const player2Image = new Image();
        player2Image.src = 'images/p2-turtle.png';

        // Disable Start Button until all images are loaded
        startButton.disabled = true;

        let imagesLoaded = 0;
        const totalImages = 5; // background, shark, coin, p1, p2

        function imageLoadedHandler() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                // All images loaded, enable the start button
                startButton.disabled = false;
                console.log("All images loaded successfully.");
            }
        }

        function imageErrorHandler(e) {
            console.error("Error loading image:", e.target.src);
            alert("Error loading image: " + e.target.src);
        }

        // Attach onload and onerror handlers for images
        backgroundImage.onload = imageLoadedHandler;
        backgroundImage.onerror = imageErrorHandler;

        sharkImage.onload = imageLoadedHandler;
        sharkImage.onerror = imageErrorHandler;

        coinImage.onload = imageLoadedHandler;
        coinImage.onerror = imageErrorHandler;

        player1Image.onload = imageLoadedHandler;
        player1Image.onerror = imageErrorHandler;

        player2Image.onload = imageLoadedHandler;
        player2Image.onerror = imageErrorHandler;

        // Turtle Class
        class Turtle {
            constructor(x, y, controls, playerNumber, name, image) {
                this.x = x;
                this.y = y;
                this.size = 20; // Radius
                this.baseSpeed = 0.2; // Acceleration per frame
                this.friction = 0.98; // Friction to reduce velocity
                this.vx = 0;
                this.vy = 0;
                this.controls = controls; // Object containing control keys
                this.alive = true;
                this.visible = true;
                this.playerNumber = playerNumber; // 1 or 2
                this.name = name;
                this.image = image; // Image object
            }

            draw() {
                if (!this.visible) return;

                ctx.save(); // Save the current canvas state
                ctx.translate(this.x, this.y); // Translate to the turtle's position

                // Calculate the angle based on velocity
                let angle = 0;
                if (this.vx !== 0 || this.vy !== 0) {
                    angle = Math.atan2(this.vy, this.vx) + Math.PI / 2; // Adjust for head at top
                }

                ctx.rotate(angle); // Rotate the canvas

                // Draw the image, centered
                ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);

                ctx.restore(); // Restore the canvas state
            }

            move() {
                if (!this.alive) return;

                let isThrusting = false; // Flag to check if the turtle is applying thrust

                // Apply thrust based on keys pressed
                if (keysPressed[this.controls.up]) {
                    this.vy -= this.baseSpeed;
                    isThrusting = true;
                }
                if (keysPressed[this.controls.down]) {
                    this.vy += this.baseSpeed;
                    isThrusting = true;
                }
                if (keysPressed[this.controls.left]) {
                    this.vx -= this.baseSpeed;
                    isThrusting = true;
                }
                if (keysPressed[this.controls.right]) {
                    this.vx += this.baseSpeed;
                    isThrusting = true;
                }

                // Generate thrust bubbles if thrusting
                if (isThrusting) {
                    this.generateThrustBubbles();
                }

                // Apply friction
                this.vx *= this.friction;
                this.vy *= this.friction;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Boundary checks
                if (this.x + this.size > canvas.width) {
                    this.x = canvas.width - this.size;
                    this.vx *= -0.5; // Bounce back with damping
                }
                if (this.x - this.size < 0) {
                    this.x = this.size;
                    this.vx *= -0.5;
                }
                if (this.y + this.size > canvas.height) {
                    this.y = canvas.height - this.size;
                    this.vy *= -0.5;
                }
                if (this.y - this.size < 0) {
                    this.y = this.size;
                    this.vy *= -0.5;
                }
            }

            generateThrustBubbles() {
                // Number of bubbles per thrust
                const bubblesPerThrust = 3;

                for (let i = 0; i < bubblesPerThrust; i++) {
                    // Calculate the opposite direction of movement for bubble emission
                    const angle = Math.atan2(this.vy, this.vx) + Math.PI;
                    const offsetDistance = this.size; // Position bubbles at the edge of the turtle
                    const offsetX = this.x + Math.cos(angle) * offsetDistance;
                    const offsetY = this.y + Math.sin(angle) * offsetDistance;

                    // Randomize bubble properties slightly
                    const bubbleVx = Math.cos(angle) * (Math.random() * 0.5 - 0.25); // Slight random horizontal velocity
                    const bubbleVy = Math.sin(angle) * (Math.random() * 0.5 - 0.25); // Slight random vertical velocity

                    // Create a new thrust bubble particle
                    thrustBubbles.push(new Particle(offsetX, offsetY, {r: 255, g: 255, b: 255}, bubbleVx, bubbleVy, 30, 2));
                }
            }

            die() {
                if (!this.alive) return; // Prevent multiple deaths
                this.alive = false;
                this.visible = false;
                try {
                    collisionSound.currentTime = 0;
                    if (!sfxMuted) collisionSound.play();
                } catch (e) {
                    console.warn('collisionSound failed to play:', e);
                }
                spawnParticles(this.x, this.y, {r: 255, g: 87, b: 34}); // Red particles for collision

                // Start respawn timer (changed from 3000ms to 2000ms)
                respawnTimeouts[`player${this.playerNumber}`] = setTimeout(() => {
                    this.revive(this.playerNumber === 1 ? canvas.width * 0.25 : canvas.width * 0.75, canvas.height / 2);
                    respawnTimeouts[`player${this.playerNumber}`] = null; // Clear the timeout reference
                }, 2000); // 2 seconds respawn time
            }

            revive(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.alive = true;
                this.visible = true;
            }
        }

        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 15; // Radius
                this.image = coinImage;
                this.collectedBy = null; // 1 or 2
            }

            draw() {
                if (!this.image.complete) return; // Ensure image is loaded

                // Draw the collectible image centered
                ctx.drawImage(this.image, this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
            }
        }

        class TigerShark {
            constructor(x, y, speed = 1) {
                this.x = x;
                this.y = y;
                this.size = 17; // Reduced size by 15% (from 20 to 17)
                this.speed = speed;
                this.direction = Math.random() * Math.PI * 2; // Random movement direction
                this.image = sharkImage;
            }

            draw() {
                if (!this.image.complete) return; // Ensure image is loaded

                ctx.save(); // Save the current canvas state
                ctx.translate(this.x, this.y); // Translate to the shark's position

                // Rotate to face movement direction
                let angle = this.direction + Math.PI / 2; // Adjust for head at top

                ctx.rotate(angle);

                // Draw the shark image, centered
                ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);

                ctx.restore(); // Restore the canvas state
            }

            move() {
                // Move shark in its current direction
                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;

                // Bounce off the walls and adjust direction
                if (this.x + this.size > canvas.width || this.x - this.size < 0) {
                    this.direction = Math.PI - this.direction;
                }
                if (this.y + this.size > canvas.height || this.y - this.size < 0) {
                    this.direction = -this.direction;
                }
            }
        }

        // Particle Class
        class Particle {
            constructor(x, y, color, vx = 0, vy = 0, life = 60, size = 4) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life; // Frames
                this.opacity = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.opacity = this.life / 60;
            }

            draw() {
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Initialize Game Entities
        let player1, player2;
        let coins = [];
        let sharks = [];

        function initGame() {
            // Define controls for both players
            const controlsPlayer1 = {
                up: 'w',
                down: 's',
                left: 'a',
                right: 'd',
                color: '#00b894',
                altColor: '#00a78a'
            };

            const controlsPlayer2 = {
                up: 'i',
                down: 'k',
                left: 'j',
                right: 'l',
                color: '#FF4081',
                altColor: '#E91E63'
            };

            // Assign random names
            const { player1Name, player2Name } = assignPlayerNames();

            // Update HUD with player names
            player1NameElement.textContent = player1Name + ':';
            player2NameElement.textContent = player2Name + ':';

            // Initialize players at different positions with their respective images
            player1 = new Turtle(
                canvas.width * 0.25,
                canvas.height / 2,
                controlsPlayer1,
                1,
                player1Name,
                player1Image
            );
            player2 = new Turtle(
                canvas.width * 0.75,
                canvas.height / 2,
                controlsPlayer2,
                2,
                player2Name,
                player2Image
            );

            coins = [];
            sharks = [];
            currentLevel = 1;
            coinsPerLevel = 2;
            sharksPerLevel = 2;
            levelSpan.textContent = currentLevel;
            player1Coins = 0;
            player2Coins = 0;
            player1CountElement.textContent = player1Coins;
            player2CountElement.textContent = player2Coins;
            spawnLevelEntities();
        }

        // Spawn Entities for Current Level
        function spawnLevelEntities() {
            // Spawn fixed number of coins
            for (let i = 0; i < coinsPerLevel; i++) {
                spawnEntity('coin');
            }

            // Spawn fixed number of Tiger Sharks
            for (let i = 0; i < sharksPerLevel; i++) {
                spawnEntity('shark');
            }
        }

        // Spawn Entities without Overlapping
        function spawnEntity(type) {
            const maxAttempts = 100;
            let attempts = 0;
            let newEntity;
            let overlapping;

            do {
                const x = Math.random() * (canvas.width - 80) + 40;
                const y = Math.random() * (canvas.height - 80) + 40;

                switch(type) {
                    case 'coin':
                        newEntity = new Coin(x, y);
                        break;
                    case 'shark':
                        // Sharks have random speeds based on level
                        const speed = 1 + currentLevel * 0.2;
                        newEntity = new TigerShark(x, y, speed);
                        break;
                }

                overlapping = false;
                // Check against all existing entities and players
                const allEntities = [...coins, ...sharks, player1, player2];
                for (let entity of allEntities) {
                    if (entity && isColliding(newEntity, entity)) {
                        overlapping = true;
                        break;
                    }
                }

                attempts++;
                if (attempts > maxAttempts) {
                    // Prevent infinite loop in case of high density
                    console.warn(`Could not place a ${type} after ${maxAttempts} attempts.`);
                    break;
                }
            } while (overlapping && attempts <= maxAttempts);

            // Add the new entity to the respective array
            if (!overlapping && attempts <= maxAttempts) {
                switch(type) {
                    case 'coin':
                        coins.push(newEntity);
                        break;
                    case 'shark':
                        sharks.push(newEntity);
                        break;
                }
            }
        }

        // Collision Detection
        function isColliding(entity1, entity2) {
            const dx = entity1.x - entity2.x;
            const dy = entity1.y - entity2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (entity1.size + entity2.size + COLLISION_BUFFER);
        }

        // Handle Collision Between Two Turtles
        function handleTurtleCollision() {
            const dx = player1.x - player2.x;
            const dy = player1.y - player2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < (player1.size + player2.size + COLLISION_BUFFER)) {
                // Simple elastic collision physics
                const angle = Math.atan2(dy, dx);
                const totalMass = 1 + 1; // Assuming equal mass

                // Calculate new velocities
                const newVx1 = ((player1.vx * (1 - 1)) + (player2.vx * 2)) / totalMass;
                const newVy1 = ((player1.vy * (1 - 1)) + (player2.vy * 2)) / totalMass;
                const newVx2 = ((player2.vx * (1 - 1)) + (player1.vx * 2)) / totalMass;
                const newVy2 = ((player2.vy * (1 - 1)) + (player1.vy * 2)) / totalMass;

                player1.vx = newVx1;
                player1.vy = newVy1;
                player2.vx = newVx2;
                player2.vy = newVy2;

                // Spawn particles at collision center
                spawnParticles((player1.x + player2.x) / 2, (player1.y + player2.y) / 2, {r: 255, g: 255, b: 255});
            }
        }

        // Particle Generation
        function spawnParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        // Game Loop
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Background
            if (backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }

            // Update and Draw Thrust Bubbles
            for (let i = thrustBubbles.length - 1; i >= 0; i--) {
                const bubble = thrustBubbles[i];
                bubble.update();
                if (bubble.life <= 0) {
                    thrustBubbles.splice(i, 1);
                } else {
                    bubble.draw();
                }
            }

            // Move and Draw Players
            player1.move();
            player1.draw();

            player2.move();
            player2.draw();

            // Handle Collision Between Turtles
            handleTurtleCollision();

            // Move and Draw Sharks
            sharks.forEach(shark => {
                shark.move();
                shark.draw();
            });

            // Draw and check coins
            // Iterate in reverse to safely remove coins while iterating
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.draw();

                // Check collision with Player 1
                if (player1.alive && isColliding(player1, coin)) {
                    coin.collectedBy = 1;
                    coins.splice(i, 1); // Remove coin
                    try {
                        if (!sfxMuted) {
                            collectCoinSound.currentTime = 0;
                            collectCoinSound.play();
                        }
                    } catch (e) {
                        console.warn('collectCoinSound failed to play:', e);
                    }
                    player1Coins++;
                    player1CountElement.textContent = player1Coins;
                    spawnParticles(coin.x, coin.y, {r: 255, g: 215, b: 0}); // Gold particles for coin collection
                    checkLevelCompletion();
                    continue; // Skip checking collision with Player 2
                }

                // Check collision with Player 2
                if (player2.alive && isColliding(player2, coin)) {
                    coin.collectedBy = 2;
                    coins.splice(i, 1); // Remove coin
                    try {
                        if (!sfxMuted) {
                            collectCoinSound.currentTime = 0;
                            collectCoinSound.play();
                        }
                    } catch (e) {
                        console.warn('collectCoinSound failed to play:', e);
                    }
                    player2Coins++;
                    player2CountElement.textContent = player2Coins;
                    spawnParticles(coin.x, coin.y, {r: 255, g: 215, b: 0});
                    checkLevelCompletion();
                }
            }

            // Draw and check sharks
            sharks.forEach(shark => {
                shark.draw();
                // Check collision with Player 1
                if (player1.alive && isColliding(player1, shark)) {
                    player1.die();
                    // Removed Game Over condition when both turtles die
                }
                // Check collision with Player 2
                if (player2.alive && isColliding(player2, shark)) {
                    player2.die();
                    // Removed Game Over condition when both turtles die
                }
            });

            // Update and Draw Regular Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.update();
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    particle.draw();
                }
            }
        }

        // Check if all coins are collected to advance to next level or end game
        function checkLevelCompletion() {
            if (coins.length === 0) {
                if (currentLevel >= maxLevel) {
                    endGameAfterLevel();
                } else {
                    advanceToNextLevel();
                }
            }
        }

        // Advance to Next Level
        function advanceToNextLevel() {
            clearInterval(gameInterval);
            // Removed bgMusic.pause(); to ensure continuous music playback

            currentLevel++;
            levelSpan.textContent = currentLevel;
            try {
                if (!sfxMuted) {
                    levelUpSound.currentTime = 0;
                    levelUpSound.play();
                }
            } catch (e) {
                console.warn('levelUpSound failed to play:', e);
            }

            // Double the number of coins and sharks
            coinsPerLevel *= 2;
            sharksPerLevel *= 2;

            // Revive any dead players at starting positions
            if (!player1.alive) {
                clearTimeout(respawnTimeouts.player1);
                respawnTimeouts.player1 = null;
                player1.revive(canvas.width * 0.25, canvas.height / 2);
            }
            if (!player2.alive) {
                clearTimeout(respawnTimeouts.player2);
                respawnTimeouts.player2 = null;
                player2.revive(canvas.width * 0.75, canvas.height / 2);
            }

            // Clear remaining sharks
            sharks = [];

            // Spawn new set of coins and sharks
            spawnLevelEntities();

            // Restart game loop
            gameInterval = setInterval(gameLoop, 1000 / 60); // 60 FPS
            // Note: Do not manipulate bgMusic here to prevent restarting music
        }

        // End Game After Level 5
        function endGameAfterLevel() {
            clearInterval(gameInterval);
            try {
                bgMusic.pause();
            } catch (e) {
                console.warn('bgMusic failed to pause:', e);
            }
            finalPlayer1.textContent = player1Coins;
            finalPlayer2.textContent = player2Coins;

            // Update Game Over screen with player names
            gameOverPlayer1.textContent = player1.name;
            gameOverPlayer2.textContent = player2.name;

            // Show Game Over screen
            gameOverScreen.classList.add('active');
        }

        // End Game Immediately (Not used since Game Over when both turtles die is removed)
        function endGame() {
            clearInterval(gameInterval);
            try {
                bgMusic.pause();
            } catch (e) {
                console.warn('bgMusic failed to pause:', e);
            }
            finalPlayer1.textContent = player1Coins;
            finalPlayer2.textContent = player2Coins;

            // Update Game Over screen with player names
            gameOverPlayer1.textContent = player1.name;
            gameOverPlayer2.textContent = player2.name;

            // Show Game Over screen
            gameOverScreen.classList.add('active');
        }

        // Start Game with Countdown
        function startGameWithCountdown() {
            startScreen.classList.remove('active');
            countdownOverlay.classList.add('active');
            let countdown = 3;
            countdownNumber.textContent = countdown;

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownNumber.textContent = countdown;
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.classList.remove('active');
                    initGame();
                    gameInterval = setInterval(gameLoop, 1000 / 60); // 60 FPS
                    try {
                        if (!musicMuted) {
                            bgMusic.currentTime = 0;
                            bgMusic.play();
                        }
                    } catch (e) {
                        console.warn('bgMusic failed to play:', e);
                    }
                }
            }, 1000);
        }

        // Toggle Music Function
        function toggleMusic() {
            if (musicMuted) {
                // Unmute and play music
                bgMusic.muted = false;
                bgMusic.play().catch(e => {
                    console.warn('bgMusic failed to play:', e);
                });
                toggleMusicButton.textContent = 'Music: On';
                musicMuted = false;
            } else {
                // Mute music
                bgMusic.muted = true;
                toggleMusicButton.textContent = 'Music: Off';
                musicMuted = true;
            }
        }

        // Toggle Sound Effects Function
        function toggleSFX() {
            if (sfxMuted) {
                // Unmute sound effects
                toggleSFXButton.textContent = 'SFX: On';
                sfxMuted = false;
            } else {
                // Mute sound effects
                toggleSFXButton.textContent = 'SFX: Off';
                sfxMuted = true;
            }
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            keysPressed[e.key.toLowerCase()] = true; // Normalize keys to lowercase
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key.toLowerCase()] = false;
        });

        startButton.addEventListener('click', startGameWithCountdown);
        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.remove('active');
            // Clear any pending respawn timers
            clearTimeout(respawnTimeouts.player1);
            clearTimeout(respawnTimeouts.player2);
            respawnTimeouts.player1 = null;
            respawnTimeouts.player2 = null;
            startGameWithCountdown();
        });

        // Audio Control Button Event Listeners
        toggleMusicButton.addEventListener('click', toggleMusic);
        toggleSFXButton.addEventListener('click', toggleSFX);

        // Prevent Specific Keys from Scrolling the Page
        window.addEventListener("keydown", function(e) {
            if(["w","a","s","d","i","j","k","l"].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        }, false);

        // Set initial music volume to 40% once the music is loaded
        bgMusic.addEventListener('canplaythrough', () => {
            bgMusic.volume = 0.4; // 40% volume
        });
    </script>
</body>
</html>

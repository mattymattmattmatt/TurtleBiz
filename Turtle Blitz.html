<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Turtle Blitz</title>
    <style>
        /* Reset default margins and paddings */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #1e1e1e;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* Container for the game and HUD */
        .game-container {
            position: relative;
            margin-top: 20px;
        }

        /* Canvas Styling */
        #gameCanvas {
            background-color: #2c2c2c;
            border: 3px solid #00b894;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 184, 148, 0.7);
        }

        /* HUD Styling */
        #hud {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 50px;
            width: 100%;
            max-width: 800px;
            font-size: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }

        #hud .player-tally, #hud .timer-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Audio Controls Styling */
        #audioControls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }

        #audioControls button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            background-color: #34495e;
            border: none;
            color: #ecf0f1;
            border-radius: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
        }

        #audioControls button:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
        }

        #audioControls button:active {
            background-color: #1a252f;
            transform: translateY(0);
        }

        /* Start, Countdown, and Game Over Screens */
        #startScreen, #gameOverScreen, #countdownOverlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background-color: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 2px solid #00b894;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0, 184, 148, 0.9);
            z-index: 100; /* Ensures overlaying */
            display: none; /* Hidden by default */
        }

        #startScreen.active, #countdownOverlay.active {
            display: block;
        }

        #gameOverScreen.active {
            display: block;
        }

        #startScreen h1, #gameOverScreen h1, #countdownOverlay h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #00b894;
            text-shadow: 2px 2px #000;
        }

        #startScreen p, #gameOverScreen p {
            font-size: 18px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        #countdownOverlay h1 {
            font-size: 100px;
            color: #FFD700;
            text-shadow: 3px 3px #000;
        }

        button {
            padding: 12px 30px;
            font-size: 18px;
            cursor: pointer;
            background-color: #00b894;
            border: none;
            color: #fff;
            border-radius: 25px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 5px 15px rgba(0, 184, 148, 0.4);
        }

        button:hover {
            background-color: #019875;
            transform: translateY(-2px);
        }

        button:active {
            background-color: #017d61;
            transform: translateY(0);
        }

        /* Rules Section Styling */
        #rules {
            max-width: 800px;
            width: 90%;
            margin: 30px auto;
            padding: 20px 30px;
            background-color: #2c2c2c;
            border: 2px solid #00b894;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 184, 148, 0.5);
        }

        #rules h2 {
            text-align: center;
            margin-bottom: 15px;
            color: #00b894;
            text-shadow: 1px 1px #000;
        }

        #rules ul {
            list-style-type: disc;
            padding-left: 20px;
            line-height: 1.6;
        }

        #rules ul ul {
            list-style-type: circle;
            padding-left: 20px;
        }

        /* Responsive Design */
        @media (max-width: 850px) {
            #hud {
                flex-direction: column;
                gap: 10px;
                font-size: 18px;
            }

            button {
                padding: 10px 25px;
                font-size: 16px;
            }

            #rules {
                padding: 15px 20px;
            }

            #rules h2 {
                font-size: 24px;
            }

            #rules ul {
                font-size: 16px;
            }

            #countdownOverlay h1 {
                font-size: 60px;
            }
        }

        /* Animation Classes */
        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* Highlight Winner Styles */
        .winner {
            color: #FFD700;
            font-weight: bold;
            text-shadow: 2px 2px #000;
        }

        /* Timer Pulsing Effect */
        .pulse-red {
            animation: pulseRed 1s infinite;
        }

        @keyframes pulseRed {
            0% { color: #fff; }
            50% { color: #FF4136; }
            100% { color: #fff; }
        }
    </style>
</head>
<body>
    <!-- Game and HUD Container -->
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="hud">
            <div class="player-tally" id="player1Tally">
                <strong id="player1Name" style="color:#00b894;"></strong> <span id="player1Count">0</span>
            </div>
            <div class="timer-display">
                <strong>Time Left:</strong> <span id="timer">60</span>s
            </div>
            <div class="player-tally" id="player2Tally">
                <strong id="player2Name" style="color:#FF4081;"></strong> <span id="player2Count">0</span>
            </div>
        </div>
    </div>

    <!-- Audio Controls -->
    <div id="audioControls">
        <button id="toggleMusic">Music: On</button>
        <button id="toggleSFX">SFX: On</button>
    </div>

    <!-- Start Screen -->
    <div id="startScreen" class="active">
        <h1>Turtle Blitz</h1>
        <p>Navigate your turtles through the ocean, collect coins, and avoid Tiger Sharks to score as many coins as possible within 1 minute!</p>
        <button id="startButton" disabled>Start Game</button> <!-- Initially disabled until images load -->
    </div>

    <!-- Countdown Overlay -->
    <div id="countdownOverlay">
        <h1 id="countdownNumber">3</h1>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <h1>Game Over</h1>
        <p><strong id="gameOverPlayer1"></strong> Coins Collected: <span id="finalPlayer1">0</span></p>
        <p><strong id="gameOverPlayer2"></strong> Coins Collected: <span id="finalPlayer2">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <!-- Game Rules Section -->
    <div id="rules">
        <h2>How to Play "Turtle Blitz"</h2>
        <p>Welcome to "Turtle Blitz"! In this retro-inspired arcade game, you and your partner take on the roles of diligent office turtles navigating through a hazardous ocean environment. Your goal is to collect as many treasure as possible within 1 minute while avoiding obstacles. Here's how to get started:</p>
        <ul>
            <li><strong>Controls:</strong>
                <ul>
                    <li><strong>Player 1:</strong> <code>W</code> (Up), <code>A</code> (Left), <code>S</code> (Down), <code>D</code> (Right) to apply thrust and move.</li>
                    <li><strong>Player 2:</strong> <code>I</code> (Up), <code>J</code> (Left), <code>K</code> (Down), <code>L</code> (Right) to apply thrust and move.</li>
                </ul>
            </li>
            <li><strong>Objectives:</strong>
                <ul>
                    <li>Collect <span style="color:#FFD700;">Coins</span> to score points.</li>
                    <li>Avoid <span style="color:#FF5722;">Tiger Sharks</span> that can eliminate a turtle upon collision.</li>
                </ul>
            </li>
            <li><strong>Game Flow:</strong>
                <ul>
                    <li>You have 1 minute to collect as many coins as possible.</li>
                    <li>There is always 1 coin on the field. Collecting a coin spawns another at a random position.</li>
                    <li>The game starts with 1 Tiger Shark, and every 3 seconds, another shark enters the playfield from a random position within the game bounds.</li>
                    <li>If a turtle gets eaten by a Tiger Shark, it becomes hidden and will respawn after 2 seconds.</li>
                    <li>End the game after 1 minute and see who collected the most coins.</li>
                    <li>Restart the game by clicking the "Play Again" button on the Game Over screen.</li>
                </ul>
            </li>
        </ul>
    </div>

    <!-- Audio Elements -->
    <audio id="bgMusic" loop>
        <source src="audio/background-music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="collectCoinSound">
        <source src="audio/collect-task.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    <audio id="collisionSound">
        <source src="audio/collision.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <!-- Voice Lines Audio Elements -->
    <div id="voiceLines" style="display: none;">
        <script>
            const voiceLines = [];
            const totalVoiceLines = 40;
            for (let i = 1; i <= totalVoiceLines; i++) {
                const audio = new Audio(`audio/${i.toString().padStart(2, '0')}.mp3`);
                audio.preload = 'auto';
                voiceLines.push(audio);
            }
        </script>
    </div>

    <script>
        // Get Canvas and Context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // HUD Elements
        const timerSpan = document.getElementById('timer');
        const player1CountElement = document.getElementById('player1Count');
        const player2CountElement = document.getElementById('player2Count');
        const player1NameElement = document.getElementById('player1Name');
        const player2NameElement = document.getElementById('player2Name');
        const gameOverPlayer1 = document.getElementById('gameOverPlayer1');
        const gameOverPlayer2 = document.getElementById('gameOverPlayer2');

        // Start, Countdown, and Game Over Screens
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const countdownNumber = document.getElementById('countdownNumber');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalPlayer1 = document.getElementById('finalPlayer1');
        const finalPlayer2 = document.getElementById('finalPlayer2');
        const restartButton = document.getElementById('restartButton');

        // Audio Elements
        const bgMusic = document.getElementById('bgMusic');
        const collectCoinSound = document.getElementById('collectCoinSound');
        const collisionSound = document.getElementById('collisionSound');

        // Audio Control Buttons
        const toggleMusicButton = document.getElementById('toggleMusic');
        const toggleSFXButton = document.getElementById('toggleSFX');

        // Game Variables
        let gameInterval;
        let gameTimerInterval;
        let sharkSpawnInterval;
        let gameTime = 60; // 60 seconds
        let keysPressed = {};

        // Collision Buffer
        const COLLISION_BUFFER = 5;

        // Tally Variables
        let player1Coins = 0;
        let player2Coins = 0;

        // Particle Management
        let particles = [];
        let thrustBubbles = []; // Array for thrust bubbles

        // Respawn Flags
        let respawnTimeouts = {
            player1: null,
            player2: null
        };

        // Audio Control States
        let musicMuted = false;
        let sfxMuted = false;

        // List of 100 Unique Names
        const nameList = [
            "Matt", "Seth", "Caleb", "Gavan", "Tina-Marie", "Steven", "Neil", "Craig",
            "George", "Johan", "Heino", "Simon", "Tanja", "Marion", "Logan", "Geoff",
            "Guihlem", "Ben", "Liam", "Mel", "Julie", "Chantal", "Katie",
            "Andrew", "Devon", "Luca", "David", "Surge", "Dan",
            "Oceane", "Remi", "Paul", "Henry", "Isla", "Jack", "Katherine", "Leo",
            "Mia", "Noah", "Olivia", "Parker", "Quinn", "Riley", "Samuel", "Sophia",
            "Thomas", "Uma", "Victoria", "William", "Ximena", "Yosef", "Zara",
            "Aaron", "Bianca", "Charles", "Delilah", "Elijah", "Freya", "James",
            "Hazel", "Ian", "Scott", "Paulo", "Chris", "Brian", "Natalie",
            "Owen", "Poopy", "Quincy", "Rowan", "Turtle Biz", "Tristan", "Smelly",
            "Vincent", "Willow", "Xenia", "Yvonne", "Zachary", "Ada", "Brandon",
            "Clara", "Dominic", "Emilia", "Finn", "Georgia", "Hudson", "Ivy",
            "Jasper", "Kylie", "Lucas", "Madeline", "Jerome"
        ];

        // Shuffle Function to Randomize Names
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Assign Random Names to Players
        function assignPlayerNames() {
            const shuffledNames = shuffle([...nameList]);
            const player1Name = shuffledNames.pop();
            const player2Name = shuffledNames.pop();
            return { player1Name, player2Name };
        }

        // Load Images
        const backgroundImage = new Image();
        backgroundImage.src = 'images/turtle-gamebg.png';

        const sharkImage1 = new Image();
        sharkImage1.src = 'images/shark.png';

        const sharkImage2 = new Image();
        sharkImage2.src = 'images/shark2.png';

        const coinImage = new Image();
        coinImage.src = 'images/gamecoin.png';

        // Load Turtle Images
        const player1Image1 = new Image();
        player1Image1.src = 'images/p1-turtle.png';

        const player1Image2 = new Image();
        player1Image2.src = 'images/p1-turtle2.png';

        const player2Image1 = new Image();
        player2Image1.src = 'images/p2-turtle.png';

        const player2Image2 = new Image();
        player2Image2.src = 'images/p2-turtle2.png';

        // Disable Start Button until all images are loaded
        startButton.disabled = true;

        let imagesLoaded = 0;
        const totalImages = 8; // background, shark1, shark2, coin, p1-turtle, p1-turtle2, p2-turtle, p2-turtle2

        function imageLoadedHandler() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                // All images loaded, enable the start button
                startButton.disabled = false;
                console.log("All images loaded successfully.");
            }
        }

        function imageErrorHandler(e) {
            console.error("Error loading image:", e.target.src);
            alert("Error loading image: " + e.target.src);
        }

        // Attach onload and onerror handlers for images
        backgroundImage.onload = imageLoadedHandler;
        backgroundImage.onerror = imageErrorHandler;

        sharkImage1.onload = imageLoadedHandler;
        sharkImage1.onerror = imageErrorHandler;

        sharkImage2.onload = imageLoadedHandler;
        sharkImage2.onerror = imageErrorHandler;

        coinImage.onload = imageLoadedHandler;
        coinImage.onerror = imageErrorHandler;

        player1Image1.onload = imageLoadedHandler;
        player1Image1.onerror = imageErrorHandler;

        player1Image2.onload = imageLoadedHandler;
        player1Image2.onerror = imageErrorHandler;

        player2Image1.onload = imageLoadedHandler;
        player2Image1.onerror = imageErrorHandler;

        player2Image2.onload = imageLoadedHandler;
        player2Image2.onerror = imageErrorHandler;

        // Turtle Class
        class Turtle {
            constructor(x, y, controls, playerNumber, name, image1, image2) {
                this.x = x;
                this.y = y;
                this.size = 20; // Radius
                this.baseSpeed = 0.2; // Acceleration per frame
                this.friction = 0.98; // Friction to reduce velocity
                this.vx = 0;
                this.vy = 0;
                this.controls = controls; // Object containing control keys
                this.alive = true;
                this.visible = true;
                this.playerNumber = playerNumber; // 1 or 2
                this.name = name;
                this.image1 = image1; // First image
                this.image2 = image2; // Second image
                this.currentImageIndex = 0; // 0 or 1
                this.swapCounter = 0;
                this.swapInterval = 30; // Initial swap interval (frames)
                this.invulnerableUntil = 0; // Timestamp until which turtle is invulnerable
            }

            isInvulnerable() {
                return Date.now() < this.invulnerableUntil;
            }

            draw() {
                if (!this.visible) return;

                // Handle flashing when invulnerable
                if (this.isInvulnerable()) {
                    // Make the turtle flash by toggling transparency
                    // Every frame, switch between 50% and 100% opacity
                    ctx.save();
                    const flashing = Math.floor(Date.now() / 100) % 2 === 0;
                    ctx.globalAlpha = flashing ? 0.5 : 1.0;
                }

                // Calculate speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const maxSpeed = 5; // Define maximum speed for animation scaling
                const minSwapInterval = 5; // Minimum frames between swaps
                const maxSwapInterval = 30; // Maximum frames between swaps
                const speedThreshold = 0.1; // Threshold to consider movement

                if (speed > speedThreshold) {
                    const clampedSpeed = Math.min(speed, maxSpeed);
                    // Inversely proportional swap interval: faster speed => shorter interval
                    this.swapInterval = maxSwapInterval - (clampedSpeed / maxSpeed) * (maxSwapInterval - minSwapInterval);

                    this.swapCounter++;

                    if (this.swapCounter >= this.swapInterval) {
                        this.currentImageIndex = (this.currentImageIndex + 1) % 2;
                        this.swapCounter = 0;
                    }
                } else {
                    // If not moving, reset to first image
                    this.currentImageIndex = 0;
                    this.swapCounter = 0;
                }

                const currentImage = this.currentImageIndex === 0 ? this.image1 : this.image2;

                ctx.save(); // Save the current canvas state
                ctx.translate(this.x, this.y); // Translate to the turtle's position

                // Calculate the angle based on velocity
                let angle = 0;
                if (this.vx !== 0 || this.vy !== 0) {
                    angle = Math.atan2(this.vy, this.vx) + Math.PI / 2; // Adjust for head at top
                }

                ctx.rotate(angle); // Rotate the canvas

                // Draw the current image, centered
                ctx.drawImage(currentImage, -this.size, -this.size, this.size * 2, this.size * 2);

                ctx.restore(); // Restore the canvas state

                if (this.isInvulnerable()) {
                    ctx.restore(); // Restore globalAlpha if we changed it
                }
            }

            move() {
                if (!this.alive) return;

                let isThrusting = false; // Flag to check if the turtle is applying thrust

                // Apply thrust based on keys pressed
                if (keysPressed[this.controls.up]) {
                    this.vy -= this.baseSpeed;
                    isThrusting = true;
                }
                if (keysPressed[this.controls.down]) {
                    this.vy += this.baseSpeed;
                    isThrusting = true;
                }
                if (keysPressed[this.controls.left]) {
                    this.vx -= this.baseSpeed;
                    isThrusting = true;
                }
                if (keysPressed[this.controls.right]) {
                    this.vx += this.baseSpeed;
                    isThrusting = true;
                }

                // Generate thrust bubbles if thrusting
                if (isThrusting) {
                    this.generateThrustBubbles();
                }

                // Apply friction
                this.vx *= this.friction;
                this.vy *= this.friction;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Boundary checks
                if (this.x + this.size > canvas.width) {
                    this.x = canvas.width - this.size;
                    this.vx *= -0.5; // Bounce back with damping
                }
                if (this.x - this.size < 0) {
                    this.x = this.size;
                    this.vx *= -0.5;
                }
                if (this.y + this.size > canvas.height) {
                    this.y = canvas.height - this.size;
                    this.vy *= -0.5;
                }
                if (this.y - this.size < 0) {
                    this.y = this.size;
                    this.vy *= -0.5;
                }
            }

            generateThrustBubbles() {
                // Number of bubbles per thrust
                const bubblesPerThrust = 3;

                for (let i = 0; i < bubblesPerThrust; i++) {
                    // Calculate the opposite direction of movement for bubble emission
                    const angle = Math.atan2(this.vy, this.vx) + Math.PI;
                    const offsetDistance = this.size; // Position bubbles at the edge of the turtle
                    const offsetX = this.x + Math.cos(angle) * offsetDistance;
                    const offsetY = this.y + Math.sin(angle) * offsetDistance;

                    // Randomize bubble properties slightly
                    const bubbleVx = Math.cos(angle) * (Math.random() * 0.5 - 0.25);
                    const bubbleVy = Math.sin(angle) * (Math.random() * 0.5 - 0.25);

                    // Create a new thrust bubble particle
                    thrustBubbles.push(new Particle(offsetX, offsetY, {r: 255, g: 255, b: 255}, bubbleVx, bubbleVy, 30, 2));
                }
            }

            die() {
                if (!this.alive) return; // Prevent multiple deaths
                this.alive = false;
                this.visible = false;
                try {
                    collisionSound.currentTime = 0;
                    if (!sfxMuted) collisionSound.play();
                } catch (e) {
                    console.warn('collisionSound failed to play:', e);
                }
                spawnParticles(this.x, this.y, {r: 255, g: 87, b: 34}); // Red particles for collision

                // Start respawn timer (2 seconds)
                respawnTimeouts[`player${this.playerNumber}`] = setTimeout(() => {
                    this.revive(this.playerNumber === 1 ? canvas.width * 0.25 : canvas.width * 0.75, canvas.height / 2);
                    respawnTimeouts[`player${this.playerNumber}`] = null; // Clear the timeout reference
                }, 2000);
            }

            revive(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.alive = true;
                this.visible = true;
                // Set 1 second of invulnerability
                this.invulnerableUntil = Date.now() + 1000;
            }
        }

        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 15; // Radius
                this.image = coinImage;
                this.collectedBy = null; // 1 or 2
            }

            draw() {
                if (!this.image.complete) return; // Ensure image is loaded
                ctx.drawImage(this.image, this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
            }
        }

        class TigerShark {
            constructor(x, y, speed = 1, image1, image2) {
                this.x = x;
                this.y = y;
                this.size = 17;
                this.speed = speed;
                this.direction = Math.random() * Math.PI * 2;
                this.image1 = image1;
                this.image2 = image2;
                this.currentImageIndex = 0;
                this.swapCounter = 0;
                this.swapInterval = 30;
            }

            draw() {
                const speed = this.speed;
                const maxSpeed = 5;
                const minSwapInterval = 5;
                const maxSwapInterval = 30;
                const speedThreshold = 0.1;

                if (speed > speedThreshold) {
                    const clampedSpeed = Math.min(speed, maxSpeed);
                    this.swapInterval = maxSwapInterval - (clampedSpeed / maxSpeed) * (maxSwapInterval - minSwapInterval);

                    this.swapCounter++;

                    if (this.swapCounter >= this.swapInterval) {
                        this.currentImageIndex = (this.currentImageIndex + 1) % 2;
                        this.swapCounter = 0;
                    }
                } else {
                    this.currentImageIndex = 0;
                    this.swapCounter = 0;
                }

                const currentImage = this.currentImageIndex === 0 ? this.image1 : this.image2;

                ctx.save();
                ctx.translate(this.x, this.y);

                let angle = this.direction + Math.PI / 2;
                ctx.rotate(angle);

                ctx.drawImage(currentImage, -this.size, -this.size, this.size * 2, this.size * 2);
                ctx.restore();
            }

            move() {
                this.x += Math.cos(this.direction) * this.speed;
                this.y += Math.sin(this.direction) * this.speed;

                if (this.x + this.size > canvas.width || this.x - this.size < 0) {
                    this.direction = Math.PI - this.direction;
                    this.x += Math.cos(this.direction) * this.speed;
                }
                if (this.y + this.size > canvas.height || this.y - this.size < 0) {
                    this.direction = -this.direction;
                    this.y += Math.sin(this.direction) * this.speed;
                }
            }
        }

        // Particle Class
        class Particle {
            constructor(x, y, color, vx = 0, vy = 0, life = 60, size = 4) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.opacity = 1;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                this.opacity = this.life / 60;
            }

            draw() {
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Initialize Game Entities
        let player1, player2;
        let coins = [];
        let sharks = [];

        function initGame() {
            const controlsPlayer1 = {
                up: 'w',
                down: 's',
                left: 'a',
                right: 'd',
                color: '#00b894',
                altColor: '#00a78a'
            };

            const controlsPlayer2 = {
                up: 'i',
                down: 'k',
                left: 'j',
                right: 'l',
                color: '#FF4081',
                altColor: '#E91E63'
            };

            const { player1Name, player2Name } = assignPlayerNames();
            player1NameElement.textContent = player1Name + ':';
            player2NameElement.textContent = player2Name + ':';

            player1 = new Turtle(
                canvas.width * 0.25,
                canvas.height / 2,
                controlsPlayer1,
                1,
                player1Name,
                player1Image1,
                player1Image2
            );
            player2 = new Turtle(
                canvas.width * 0.75,
                canvas.height / 2,
                controlsPlayer2,
                2,
                player2Name,
                player2Image1,
                player2Image2
            );

            coins = [];
            sharks = [];
            gameTime = 60;
            timerSpan.textContent = gameTime;
            player1Coins = 0;
            player2Coins = 0;
            player1CountElement.textContent = player1Coins;
            player2CountElement.textContent = player2Coins;
            spawnInitialCoin();
            spawnInitialSharks();
            startSharkSpawner();
            startTimer();
        }

        function spawnInitialCoin() {
            spawnEntity('coin');
        }

        function spawnEntity(type) {
            const maxAttempts = 100;
            let attempts = 0;
            let newEntity;
            let overlapping;

            do {
                const x = Math.random() * (canvas.width - 80) + 40;
                const y = Math.random() * (canvas.height - 80) + 40;

                switch(type) {
                    case 'coin':
                        newEntity = new Coin(x, y);
                        break;
                    case 'shark':
                        const speed = 1 + Math.random() * 1;
                        newEntity = new TigerShark(x, y, speed, sharkImage1, sharkImage2);
                        break;
                }

                overlapping = false;
                const allEntities = [...coins, ...sharks, player1, player2];
                for (let entity of allEntities) {
                    if (entity && isColliding(newEntity, entity)) {
                        overlapping = true;
                        break;
                    }
                }

                attempts++;
                if (attempts > maxAttempts) {
                    console.warn(`Could not place a ${type} after ${maxAttempts} attempts.`);
                    break;
                }
            } while (overlapping && attempts <= maxAttempts);

            if (!overlapping && attempts <= maxAttempts) {
                switch(type) {
                    case 'coin':
                        coins.push(newEntity);
                        break;
                    case 'shark':
                        sharks.push(newEntity);
                        break;
                }
            }
        }

        function isColliding(entity1, entity2) {
            const dx = entity1.x - entity2.x;
            const dy = entity1.y - entity2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (entity1.size + entity2.size + COLLISION_BUFFER);
        }

        function handleTurtleCollision() {
            // Only check if both turtles are alive, visible and not invulnerable
            if (!player1.alive || !player1.visible || player1.isInvulnerable()) return;
            if (!player2.alive || !player2.visible || player2.isInvulnerable()) return;

            const dx = player1.x - player2.x;
            const dy = player1.y - player2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < (player1.size + player2.size + COLLISION_BUFFER)) {
                const nx = dx / distance;
                const ny = dy / distance;

                const dvx = player1.vx - player2.vx;
                const dvy = player1.vy - player2.vy;

                const relVel = dvx * nx + dvy * ny;
                if (relVel > 0) return;

                const impulse = 2 * relVel / (1 + 1);
                player1.vx -= impulse * nx;
                player1.vy -= impulse * ny;
                player2.vx += impulse * nx;
                player2.vy += impulse * ny;

                spawnParticles((player1.x + player2.x) / 2, (player1.y + player2.y) / 2, {r: 255, g: 255, b: 255});

                if (!sfxMuted && voiceLines.length > 0) {
                    const randomIndex = Math.floor(Math.random() * voiceLines.length);
                    const selectedVoiceLine = voiceLines[randomIndex];
                    selectedVoiceLine.currentTime = 0; 
                    selectedVoiceLine.play().catch(e => {
                        console.warn('Voice line failed to play:', e);
                    });
                }
            }
        }

        function spawnParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function spawnInitialSharks() {
            spawnEntity('shark');
        }

        function spawnSharkInsideBounds() {
            const maxAttempts = 100;
            let attempts = 0;
            let newShark;
            let overlapping;

            do {
                const x = Math.random() * (canvas.width - 40) + 20;
                const y = Math.random() * (canvas.height - 40) + 20;
                const speed = 1 + Math.random();

                newShark = new TigerShark(x, y, speed, sharkImage1, sharkImage2);

                overlapping = false;
                const allEntities = [...sharks, player1, player2];
                for (let entity of allEntities) {
                    if (entity && isColliding(newShark, entity)) {
                        overlapping = true;
                        break;
                    }
                }

                attempts++;
                if (attempts > maxAttempts) {
                    console.warn(`Could not place a shark inside bounds after ${maxAttempts} attempts.`);
                    break;
                }
            } while (overlapping && attempts <= maxAttempts);

            if (!overlapping && attempts <= maxAttempts) {
                sharks.push(newShark);
                console.log(`Spawned new shark at (${newShark.x.toFixed(2)}, ${newShark.y.toFixed(2)})`);
            }
        }

        function startSharkSpawner() {
            sharkSpawnInterval = setInterval(() => {
                spawnSharkInsideBounds();
            }, 3000);
            console.log("Shark spawner started.");
        }

        function stopSharkSpawner() {
            clearInterval(sharkSpawnInterval);
            console.log("Shark spawner stopped.");
        }

        function startTimer() {
            gameTimerInterval = setInterval(() => {
                gameTime--;
                timerSpan.textContent = gameTime;

                if (gameTime <= 5 && gameTime > 0) {
                    timerSpan.classList.add('pulse-red');
                } else {
                    timerSpan.classList.remove('pulse-red');
                }

                if (gameTime <= 0) {
                    endGame();
                }
            }, 1000);
            console.log("Game timer started.");
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }

            // Update and Draw Thrust Bubbles
            for (let i = thrustBubbles.length - 1; i >= 0; i--) {
                const bubble = thrustBubbles[i];
                bubble.update();
                if (bubble.life <= 0) {
                    thrustBubbles.splice(i, 1);
                } else {
                    bubble.draw();
                }
            }

            player1.move();
            player1.draw();

            player2.move();
            player2.draw();

            handleTurtleCollision();

            sharks.forEach(shark => {
                shark.move();
                shark.draw();
            });

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.draw();

                // Check collision with Player 1
                if (player1.alive && player1.visible && !player1.isInvulnerable() && isColliding(player1, coin)) {
                    coin.collectedBy = 1;
                    coins.splice(i, 1);
                    try {
                        if (!sfxMuted) {
                            collectCoinSound.currentTime = 0;
                            collectCoinSound.play();
                        }
                    } catch (e) {
                        console.warn('collectCoinSound failed to play:', e);
                    }
                    player1Coins++;
                    player1CountElement.textContent = player1Coins;
                    spawnParticles(coin.x, coin.y, {r: 255, g: 215, b: 0});
                    spawnEntity('coin');
                    continue;
                }

                // Check collision with Player 2
                if (player2.alive && player2.visible && !player2.isInvulnerable() && isColliding(player2, coin)) {
                    coin.collectedBy = 2;
                    coins.splice(i, 1);
                    try {
                        if (!sfxMuted) {
                            collectCoinSound.currentTime = 0;
                            collectCoinSound.play();
                        }
                    } catch (e) {
                        console.warn('collectCoinSound failed to play:', e);
                    }
                    player2Coins++;
                    player2CountElement.textContent = player2Coins;
                    spawnParticles(coin.x, coin.y, {r: 255, g: 215, b: 0});
                    spawnEntity('coin');
                }
            }

            sharks.forEach(shark => {
                // Check collision with Player 1
                if (player1.alive && player1.visible && !player1.isInvulnerable() && isColliding(player1, shark)) {
                    player1.die();
                }
                // Check collision with Player 2
                if (player2.alive && player2.visible && !player2.isInvulnerable() && isColliding(player2, shark)) {
                    player2.die();
                }
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.update();
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    particle.draw();
                }
            }
        }

        function endGame() {
            clearInterval(gameInterval);
            clearInterval(gameTimerInterval);
            stopSharkSpawner();
            try {
                bgMusic.pause();
            } catch (e) {
                console.warn('bgMusic failed to pause:', e);
            }
            finalPlayer1.textContent = player1Coins;
            finalPlayer2.textContent = player2Coins;

            if (player1Coins > player2Coins) {
                gameOverPlayer1.classList.add('winner');
                gameOverPlayer2.classList.remove('winner');
            } else if (player2Coins > player1Coins) {
                gameOverPlayer2.classList.add('winner');
                gameOverPlayer1.classList.remove('winner');
            } else {
                gameOverPlayer1.classList.add('winner');
                gameOverPlayer2.classList.add('winner');
            }

            gameOverPlayer1.textContent = player1.name;
            gameOverPlayer2.textContent = player2.name;

            gameOverScreen.classList.add('active');
            console.log("Game Over.");
        }

        function startGameWithCountdown() {
            startScreen.classList.remove('active');
            countdownOverlay.classList.add('active');
            let countdown = 3;
            countdownNumber.textContent = countdown;

            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownNumber.textContent = countdown;
                } else {
                    clearInterval(countdownInterval);
                    countdownOverlay.classList.remove('active');
                    initGame();
                    gameInterval = setInterval(gameLoop, 1000 / 60);
                    try {
                        if (!musicMuted) {
                            bgMusic.currentTime = 0;
                            bgMusic.play();
                        }
                    } catch (e) {
                        console.warn('bgMusic failed to play:', e);
                    }
                    console.log("Game started.");
                }
            }, 1000);
        }

        function toggleMusic() {
            if (musicMuted) {
                bgMusic.muted = false;
                bgMusic.play().catch(e => {
                    console.warn('bgMusic failed to play:', e);
                });
                toggleMusicButton.textContent = 'Music: On';
                musicMuted = false;
            } else {
                bgMusic.muted = true;
                toggleMusicButton.textContent = 'Music: Off';
                musicMuted = true;
            }
        }

        function toggleSFX() {
            if (sfxMuted) {
                toggleSFXButton.textContent = 'SFX: On';
                sfxMuted = false;
            } else {
                toggleSFXButton.textContent = 'SFX: Off';
                sfxMuted = true;
            }
        }

        document.addEventListener('keydown', (e) => {
            keysPressed[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key.toLowerCase()] = false;
        });

        startButton.addEventListener('click', startGameWithCountdown);
        restartButton.addEventListener('click', () => {
            gameOverScreen.classList.remove('active');
            gameOverPlayer1.classList.remove('winner');
            gameOverPlayer2.classList.remove('winner');
            clearTimeout(respawnTimeouts.player1);
            clearTimeout(respawnTimeouts.player2);
            respawnTimeouts.player1 = null;
            respawnTimeouts.player2 = null;
            startGameWithCountdown();
            console.log("Game restarted.");
        });

        toggleMusicButton.addEventListener('click', toggleMusic);
        toggleSFXButton.addEventListener('click', toggleSFX);

        window.addEventListener("keydown", function(e) {
            if(["w","a","s","d","i","j","k","l"].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        }, false);

        bgMusic.addEventListener('canplaythrough', () => {
            bgMusic.volume = 0.4;
        });
    </script>
</body>
</html>
